"""Shell completion generators for pyprland.

Generates dynamic shell completions based on loaded plugins and configuration.
"""

from __future__ import annotations

import os
import re
from pathlib import Path
from typing import TYPE_CHECKING

from .builtin_commands import BUILTIN_COMMANDS
from .constants import SUPPORTED_SHELLS

if TYPE_CHECKING:
    from .manager import Pyprland

# Pattern to match <opt1|opt2|opt3> in docstrings
CHOICES_PATTERN = re.compile(r"<([^>]+\|[^>]+)>")

# Default user-level completion paths
DEFAULT_PATHS = {
    "bash": "~/.local/share/bash-completion/completions/pypr",
    "zsh": "~/.zsh/completions/_pypr",
    "fish": "~/.config/fish/completions/pypr.fish",
}


def get_default_path(shell: str) -> str:
    """Get the default user-level completion path for a shell.

    Args:
        shell: Shell type ("bash", "zsh", or "fish")

    Returns:
        Expanded absolute path to the default completion file
    """
    return os.path.expanduser(DEFAULT_PATHS[shell])


def get_completions_data(manager: Pyprland) -> dict[str, list[str]]:
    """Extract commands and their subcommand choices from loaded plugins.

    Args:
        manager: The Pyprland manager instance with loaded plugins

    Returns:
        Dict mapping command name -> list of valid subcommands/arguments
    """
    # Start with built-in commands (use subcommands from tuple[2])
    commands: dict[str, list[str]] = {cmd: list(info[2]) for cmd, info in BUILTIN_COMMANDS.items()}

    # Get scratchpad names from config for dynamic completion
    scratchpad_names: list[str] = []
    if "scratchpads" in manager.config:
        scratchpad_names = list(manager.config["scratchpads"].keys())

    for plugin in manager.plugins.values():
        for attr_name in dir(plugin):
            if not attr_name.startswith("run_"):
                continue

            method = getattr(plugin, attr_name)
            if not callable(method):
                continue

            cmd_name = attr_name[4:]  # Remove "run_" prefix
            doc = method.__doc__ or ""

            # Parse choices from docstring
            choices = _parse_docstring_choices(doc, cmd_name, scratchpad_names)
            commands[cmd_name] = choices

    # help command should complete with all available commands
    commands["help"] = sorted(commands.keys())

    return commands


def _parse_docstring_choices(doc: str, cmd_name: str, scratchpad_names: list[str]) -> list[str]:
    """Parse subcommand choices from a docstring.

    Args:
        doc: The docstring to parse
        cmd_name: Command name (for special handling)
        scratchpad_names: Available scratchpad names from config

    Returns:
        List of valid subcommand choices
    """
    # Check for <opt1|opt2|opt3> pattern
    match = CHOICES_PATTERN.search(doc)
    if match:
        choices_str = match.group(1)
        # Check if it's a fixed list like "toggle|next|prev"
        if "|" in choices_str and not any(c in choices_str for c in (" ", "<", ">")):
            return choices_str.split("|")

    # Special handling for scratchpad commands
    if cmd_name in ("toggle", "show", "hide", "attach"):
        return scratchpad_names

    return []


def generate_bash(commands: dict[str, list[str]], output_path: str) -> None:
    """Generate a minimal bash completion script.

    Args:
        commands: Dict mapping command name -> list of subcommands
        output_path: Path to write the completion script
    """
    cmd_list = " ".join(sorted(commands.keys()))

    # Build case statements for commands with subcommands
    case_statements = []
    for cmd, subcmds in sorted(commands.items()):
        if subcmds:
            subcmd_list = " ".join(subcmds)
            case_statements.append(f'            {cmd}) COMPREPLY=($(compgen -W "{subcmd_list}" -- "$cur"));;')

    case_block = "\n".join(case_statements) if case_statements else "            *) ;;"

    script = f"""# Bash completion for pypr
# Generated by: pypr compgen bash

_pypr() {{
    local cur="${{COMP_WORDS[COMP_CWORD]}}"
    local cmd="${{COMP_WORDS[1]}}"

    if [[ $COMP_CWORD -eq 1 ]]; then
        COMPREPLY=($(compgen -W "{cmd_list}" -- "$cur"))
    else
        case "$cmd" in
{case_block}
        esac
    fi
}}

complete -F _pypr pypr
"""

    Path(output_path).write_text(script, encoding="utf-8")


def generate_zsh(commands: dict[str, list[str]], output_path: str) -> None:
    """Generate a minimal zsh completion script.

    Args:
        commands: Dict mapping command name -> list of subcommands
        output_path: Path to write the completion script
    """
    # Build command list
    cmd_list = " ".join(sorted(commands.keys()))

    # Build case statements for commands with subcommands
    case_statements = []
    for cmd, subcmds in sorted(commands.items()):
        if subcmds:
            subcmd_list = " ".join(subcmds)
            case_statements.append(f"            {cmd}) _values 'subcommand' {subcmd_list};;")

    case_block = "\n".join(case_statements) if case_statements else "            *) ;;"

    script = f"""#compdef pypr
# Zsh completion for pypr
# Generated by: pypr compgen zsh

_pypr() {{
    local -a commands=({cmd_list})

    if (( CURRENT == 2 )); then
        _describe 'command' commands
    else
        local cmd="${{words[2]}}"
        case "$cmd" in
{case_block}
        esac
    fi
}}

_pypr "$@"
"""

    Path(output_path).write_text(script, encoding="utf-8")


def generate_fish(commands: dict[str, list[str]], output_path: str) -> None:
    """Generate a minimal fish completion script.

    Args:
        commands: Dict mapping command name -> list of subcommands
        output_path: Path to write the completion script
    """
    lines = [
        "# Fish completion for pypr",
        "# Generated by: pypr compgen fish",
        "",
        "# Disable file completions for pypr",
        "complete -c pypr -f",
        "",
        "# Main commands",
    ]

    # Add main commands
    lines.extend(f'complete -c pypr -n "__fish_use_subcommand" -a "{cmd}"' for cmd in sorted(commands.keys()))

    lines.append("")
    lines.append("# Subcommands")

    # Add subcommands
    for cmd, subcmds in sorted(commands.items()):
        if subcmds:
            subcmd_list = " ".join(subcmds)
            lines.append(f'complete -c pypr -n "__fish_seen_subcommand_from {cmd}" -a "{subcmd_list}"')

    script = "\n".join(lines) + "\n"
    Path(output_path).write_text(script, encoding="utf-8")


GENERATORS = {
    "bash": generate_bash,
    "zsh": generate_zsh,
    "fish": generate_fish,
}


def _get_success_message(shell: str, output_path: str, used_default: bool) -> str:
    """Generate a friendly success message after installing completions.

    Args:
        shell: Shell type
        output_path: Path where completions were written
        used_default: Whether the default path was used

    Returns:
        User-friendly success message
    """
    # Use ~ in display path for readability
    display_path = output_path.replace(os.path.expanduser("~"), "~")

    if not used_default:
        return f"Completions written to {display_path}"

    if shell == "bash":
        return f"Completions installed to {display_path}\nReload your shell or run: source ~/.bashrc"

    if shell == "zsh":
        return (
            f"Completions installed to {display_path}\n"
            "Ensure ~/.zsh/completions is in your fpath. Add to ~/.zshrc:\n"
            "  fpath=(~/.zsh/completions $fpath)\n"
            "  autoload -Uz compinit && compinit\n"
            "Then reload your shell."
        )

    if shell == "fish":
        return f"Completions installed to {display_path}\nReload your shell or run: source ~/.config/fish/config.fish"

    return f"Completions written to {display_path}"


def generate_completions(manager: Pyprland, shell: str, output_path: str | None = None) -> tuple[bool, str]:
    """Generate shell completions and write to file.

    Args:
        manager: The Pyprland manager instance with loaded plugins
        shell: Shell type ("bash", "zsh", or "fish")
        output_path: Path to write the completion script (uses default if None)

    Returns:
        Tuple of (success, message). Message is error on failure, success info on success.
    """
    if shell not in GENERATORS:
        return (False, f"Unsupported shell: {shell}. Supported: {', '.join(SUPPORTED_SHELLS)}")

    # Use default path if not specified
    used_default = output_path is None
    if used_default:
        output_path = get_default_path(shell)

    if output_path is None:
        return (False, "No output path specified and could not determine default path")

    manager.log.debug("Writing completions to: %s", output_path)

    try:
        # Create parent directories if needed
        parent_dir = Path(output_path).parent
        parent_dir.mkdir(parents=True, exist_ok=True)

        commands = get_completions_data(manager)
        GENERATORS[shell](commands, output_path)
    except OSError as e:
        return (False, f"Failed to write completion file: {e}")
    except Exception as e:  # noqa: BLE001  # pylint: disable=broad-exception-caught
        return (False, f"Failed to generate completions: {e}")

    return (True, _get_success_message(shell, output_path, used_default))
